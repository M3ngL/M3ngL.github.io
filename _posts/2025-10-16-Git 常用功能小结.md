---
layout: post
title: Git 常用功能小结
category: "Other"
date: 2025-10-16
---


本文均是在远程仓库为github的环境下操作的，主要讲解私人仓库情况下的常用 git 操作，因此不会涉及合并PR分支等等

环境：git version 2.34.1 + WSL2 Ubuntu 20.04.6 LTS

## Git 基础概念

### Git 文件状态

在 git 的视角中，文件所处各种状态有以下

* **未跟踪 `Untracked`**：文件存在于工作目录，但未被 Git 跟踪（不在版本控制中）。

* **已跟踪 `Tracked`**：

  - **未修改 `Unmodified`**：文件已被 Git 跟踪，且内容与最近一次提交一致。

  - **已修改 `Modified`**：文件已被 Git 跟踪，但内容发生变化，尚未暂存。

  - **已暂存 `Staged`**：文件修改已通过 git add 添加到暂存区，准备提交。

* **忽略 `Ignored`**：文件被列入 `.gitignore`，Git 不会跟踪这些文件。
* **已提交 `Committed`**：文件修改已通过 git commit 保存到仓库的历史中。

本地提交对应于 git commit

远程推送对应于 git push

git push 后的远程仓库参数解释

* **执行 `git add` 的效果** 

未跟踪 → 已跟踪（工作目录 → 暂存区） 

已修改 → 已暂存（工作目录 → 暂存区）

* **执行 `git commit` 的效果**

已暂存 → 已提交（暂存区 → 提交历史）

---

### Git 配置文件

* **`.gitignore`**

`.gitignore` 文件是通过正则匹配方式匹配符合条件的文件名，默认不再对这些文件进行追踪

当不确定`.gitignore` 文件是否正常生效时，可以通过 git 命令查看即将被跟踪的文件

````bash
git ls-files --others --exclude-standard
````

其中 `--exclude-standard` 作用是引入了 `.gitignore `文件规则

* **`.gitmodules`**

该文件不用手动修改，通过 git 命令修改即可

指定远程仓库，在本地目录中增加子模块，路径为 `./lib/my-submodule`

````bash
git submodule add https://github.com/username/submodule-repo.git lib/my-submodule
````

向远程仓库更新下载子模块

````bash
git submodule update --init --recursive
````

* **`~/.gitconfig`**

该文件是以下命令设置的对象，设置成功后文件内容会有对应修改

````bash
git config --global xxx
````

也可以通过 `git config --list --show-origin` 查验本地系统的所有 git 设置以及设置来源

## Git 常用功能

下面将通过功能的角度来引出对应的 git 命令

### 连接远程仓库

初始化本地 git 仓库，并不是都要通过 clone 实现，也可以现在本地 `git init` 初始化后，再连接远程仓库

````bash
git remote add origin git@github.com:M3ngL/privateWork.git
````

其中 `origin` 仅是指代 `git@github.com:M3ngL/privateWork.git` 的变量，相当于远程仓库链接的本地称呼（自定义）；该变量名可以是任意的，存在的意义是为了方便后续涉及远程仓库的操作不再需要写明完整链接

> 国内通过 git 协议连接到 github 有时候连接不稳，建议使用 https 协议，即这里的远程仓库链接使用 https 协议 `https://github.com/M3ngL/privateWork.git`

查验是否设置成功

````bash
git remote -v
````

设置成功后，若远程仓库已有代码，需要 `fetch/pull`，此时由于没有设置上游分支，需要进行指定

````bash
git fetch/pull origin your_branch
````

二者的主要区别是，`pull`会自动尝试将远程仓库内容合并到本地工作目录中，而 `fetch` 不会

拉取成功后，切换到对应分支即可 `git checkout your_branch`

---

设置远程仓库后，可以**修改远程仓库链接**：

````bash
git remote set-url origin https://xx/xxx/xxx.git
````

### 指定 pull/clone depth

远程仓库可能有大文件的提交历史，导致新建的本地仓库对远程仓库的克隆或者拉取时间过长，此时设置从远程仓库获取的提交次数即可，即深度

* **仅拉取最新一次的仓库提交**

````bash
git pull --depth 1
````

* **仅对目标仓库克隆最新一次提交**

````bash
git clone --depth 1 <repository-url>
````

---

* **`git pull` 时显示本地存在修改暂未提交**

先暂存本地工作目录的修改，并进行拉取

````bash
git stash && git pull
````

> 也可以本次暂存增加信息： `git stash -m "Your info."`

拉取成功后，再将之前的本地修改从暂存栈中弹出

````bash
git stash pop
````

> `git stash` 和 `git add` 对文件的保存位置是不同的

### 检出指定 commit

* **从当前版本切换到旧版本**

````bash
git switch -d log_hash
````

* **从旧版本切换到当前分支的最新版本**

````bash
git switch branch_name
````

> 每次从新版本切换到当前分支的旧版本后，`git log` 不再能查询得到当前分支的整个历史记录，要重新返回最新版本，直接写分支名称即可

### 撤销 add/commit/push

* **在未进行提交之前，放弃本次git add的某个对象（文件/文件夹）**

`git add xxx`后，对应的文件/文件夹将处于已被跟踪 `tracked`状态，即该文件对象进入了**暂存区**，需要从 Git 的索引中移除，才能放弃本次git add的某个对象（文件/文件夹）

````bash
git rm --cached <file_path>		# 移除单个文件
git rm -r --cached <file_path>	# 移除一个文件夹及其所有内容（递归）
````

* **在进行本地提交之后但未进行远程推送，放弃某次git commit的内容**

以下提到的方法都是会将某个提交记录中所有涉及的文件对象均撤销，无法仅放弃git commit内容中的某个对象

在`git commit`之后，本地将生成对应的 log 提交记录，通过该记录来定位要放弃的 commit 对象，查询 log hash

````bash
$ git log --oneline
61e3529 add 1.txt for test.
````

**方法一**：直接撤销整个提交，**且不留下 git log 记录**，但保留更改内容，将更改内容返回到暂存区（`tracked`状态）

````bash
git reset --soft HEAD^
````

命令参数 `HEAD^` 指代当前 log 记录的头指针的上一个记录，整个命令的作用是 git 回退到头指针的上一个记录点；该方法的前提是本地有两次及以上的提交

> 若只有一次提交历史，则需要通过其他方式指定回滚的对象
>
> 即git回滚到还没有任何提交的时候，此时本地代码不会改变，仅是git记录发生了变化
>
> ````bash
> git update-ref -d HEAD master
> ````
>

**方法二**：进行新的提交，提交内容是收回指定的某次历史提交内容

> note：如果撤销对象不是最新的提交，撤销提交后，有可能导致文件内容冲突；此时需要手动解决选择，建议选择IDE进行操作

执行`git revert`命令

````bash
$ git revert 61e3529
````

执行后该命令将自动打开git设置中指定的默认编辑器，编辑本次revert commit的信息后，保存并退出即可

![image-20251015195355566](/pic/image-20251015195355566.png)

> 修改 git 的默认编辑器
>
> ````bash
> git config --global core.editor vim
> ````

再次查看 git log，可以发现操作成功

````bash
$ git log --oneline
ef609f0 Revert "add 1.txt for test."
61e3529 add 1.txt for test.
````

进一步地，当放弃某次commit内容后，若需要将内容中的某个文件对象彻底不纳入git跟踪，则继续运行`git rm --cache`即可

* **在进行远程推送之后，放弃某次git push的内容**

需要先在本地修改 git commit 记录，再进行推送，修改远程仓库的记录

**方法一**，使用 `git revert`，使用方法同《放弃某次git commit的内容》，最后进行 git push 即可

**方法二**，彻底删除提交记录，重写历史

````bash
git reset --hard log_hash^
````

此时再进行强制推送

````bash
git push --force
````

> 当远程仓库的历史记录和本地不同时，本地在进行推送时需要添加参数 `--force`

### 修改 commit info

修改最近一次本地提交的 commit 信息

````bash
git commit --amend
````

### 合并多个 commit

指定合并当前 HEAD 指针以及之前1次的提交

````bash
git rebase -i HEAD~2
````

执行后，会自动弹出

![image-20251016192348639](/pic/image-20251016192348639.png)

这里涉及到 commit 信息的选定，需要修改其中的命令 `pick`（不能全部都是 `pick` ）以满足最终合并结果 commit 的信息展示

commit 信息选定涉及的官方命令解释说明：

````bash
# Commands:
# p, pick <commit> = use commit
# r, reword <commit> = use commit, but edit the commit message
# e, edit <commit> = use commit, but stop for amending
# s, squash <commit> = use commit, but meld into previous commit
# f, fixup [-C | -c] <commit> = like "squash" but keep only the previous
#                    commit's log message, unless -C is used, in which case
#                    keep only this commit's message; -c is same as -C but
#                    opens the editor
# x, exec <command> = run command (the rest of the line) using shell
# b, break = stop here (continue rebase later with 'git rebase --continue')
# d, drop <commit> = remove commit
# l, label <label> = label current HEAD with a name
# t, reset <label> = reset HEAD to a label
# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]
# .       create a merge commit using the original merge commit's
# .       message (or the oneline, if no original merge commit was
# .       specified); use -c <commit> to reword the commit message
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# You are editing the todo file of an ongoing interactive rebase.
# To continue rebase after editing, run:
#     git rebase --continue
````

常用命令

- **pick**：使用对应历史的commit信息。
- **reword**：使用commit，修改commit信息。
- **squash**：使用commit，将commit信息合入上一个commit。
- **fixup**：使用commit，丢弃commit信息。

### 推送 large file

由于 github 有文件大小上传限制，因此单独使用 `git lfs` 命令推送本地大文件

````bash
# 跟踪大文件
git lfs track "*.zip"

# 添加文件
git add *.zip
git add .gitattributes  # 必须添加 .gitattributes 文件

# 提交
git commit -m "Upload large file via LFS"
````

其中，将自动创建 `.gitattributes` 文件并写入相应内容，git 将自动把匹配的文件交给 LFS 处理

但如果要通过 LFS 提交的文件在 `lfs track` 之前就已经进行了跟踪/提交，那么需要 `git rm --cached largefile.zip`，然后再执行 `git lfs track`

## Git 本地配置

* **git 代理设置**

git 推送以及下载仓库的网络通道与本地系统的代理不相关，即Git 的代理配置是独立的，因此需要手动指定git代理

> 如果是 linux 终端中指定了环境变量 `http_proxy`，`https_proxy`，当git通过https协议进行网路通信时会按照这两个变量的值来进行网络代理

````bash
git config --global http.proxy 'http://127.0.0.1:1080'
git config --global https.proxy 'https://127.0.0.1:1080'
````

* PC初次使用git，哪些配置是必要的

对于提交或者推送到远程仓库，需要进行`git config`设置，否则git将使用默认用户，导致之后查询log记录中，无法通过用户或者email定位

````bash
git config --global user.name "Your_Name"
git config --global user.email "your_email@example.com"
````

* 临时克隆远程仓库到本地，不进行提交或者推送操作

该情况可以不进行`git config`配置

* 查看 git 所有配置

````bash
git config --list
````

## Github 网页操作

* **修改 Github 远程仓库的默认分支**

目前 git 本地工作目录默认初始化的分支是 master，而 github 默认分支是 main；因此有时会对远程仓库的默认分支做修改

在 github setting 中设置 update default branch

![image-20251016211342346](/pic/image-20251016211342346.png)

* **通过URL查询仓库的commit记录**

通过 log hash 值在 github 网址上查询其版本，如访问

```url
 https://github.com/ArduPilot/ardupilot/commit/0b9e506
```

hash值的长度没有限制









